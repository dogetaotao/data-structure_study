#  数据结构与算法笔记

##  评判算法的指标、二分法、异或



### 1.常见的常数复杂度操作（执行时间固定，与样本量无关）

​	· 常见的算术运算（+ - * % /）

​	· 数组的寻址操作

​	· 常见的位运算（>> >>> << | & ^）

​	· 赋值、比较、自增、自减操作等

### 2.确定算法流程的总操作数量与样本数量之间的表达式关系？

​	· 想象该算法流程所处理的数据状况，按照最差的情况来

​	· 把整个流程彻底拆分成一个个基本动作，保证每个动作都是常数级别的操作

​	· 蜀国数据量为N，看看基本动作数量和N是什么关系

### 3.时间复杂度为N²的排序算法

​	· 选择排序

```java
public static void main(String[] args) {

        int arr[] = {6, 5, 3, 2, 4};

        //选择
        for (int i = 0; i < arr.length; i++) {
            //默认第一个是最小的。
            int min = arr[i];
            //记录最小的下标
            int index = i;
            //通过与后面的数据进行比较得出，最小值和下标
            for (int j = i + 1; j < arr.length; j++) {
                if (min > arr[j]) {
                    min = arr[j];
                    index = j;
                }
            }
            //然后将最小值与本次循环的，开始值交换
            int temp = arr[i];
            arr[i] = min;
            arr[index] = temp;
            //说明：将i前面的数据看成一个排好的队列，i后面的看成一个无序队列。每次只需要找无需的最小值，做替换
        }
    }
```

​	· 冒泡排序

```java
public static void main(String[] args) {

        int arr[] = {8, 5, 3, 2, 4};

        //冒泡
        for (int i = 0; i < arr.length; i++) {
            //外层循环，遍历次数
            for (int j = 0; j < arr.length - i - 1; j++) {
                //内层循环，升序（如果前一个值比后一个值大，则交换）
                //内层循环一次，获取一个最大值
                if (arr[j] > arr[j + 1]) {
                    int temp = arr[j + 1];
                    arr[j + 1] = arr[j];
                    arr[j] = temp;
                }
            }
        }
    }
```

​	· 插入排序



```java
public static void main(String[] args) {

        int arr[] = {7, 5, 3, 2, 4};

        //插入排序
        for (int i = 1; i < arr.length; i++) {
            //外层循环，从第二个开始比较
            for (int j = i; j > 0; j--) {
                //内存循环，与前面排好序的数据比较，如果后面的数据小于前面的则交换
                if (arr[j] < arr[j - 1]) {
                    int temp = arr[j - 1];
                    arr[j - 1] = arr[j];
                    arr[j] = temp;
                } else {
                    //如果不小于，说明插入完毕，退出内层循环
                    break;
                }
            }
        }
    }
```

### 4.额外空间复杂度

​	实现一个算法流程的过程中，需要开辟一些空间来支持你的算法流程

​	作为输入参数的空间，不算额外空间

​	作为输出结果的空间，不算额外空间

​	因为这些都是必要的，和实现目标有关的，都不算额外空间

​	但除此之外，你的流程还需要开辟空间来让你的流程继续下去，这部分空间就是额外空间

​	如果你的流程只需要开辟几个有限的变量，额外空间复杂度计为O(1)

### 5.常见时间复杂度

​	O(1)

​	O(log N)

​	O(N)

​	O(N*log N)

​	O(N²)  O(N³)  …… O(N^K)

​	O(2^N)   O(3^N)  …… O(K^N)

​	O(N!)

### 6.二分法



### 7.异或运算

​	· 异或运算：相同为0，不同为1.可记成无进位相加。

​	· 0^N==N   N^N==0

​	· 异或运算满足交换律和结合律  

​	· 交换a和b的值：  int a = 甲   int b = 乙

​        a = a^b    		b = a^b    		a = a^b

​        a = 甲^乙        b = 甲^乙^乙 = 甲         a = 甲^甲^乙 = 乙



##  链表、栈、队列、递归、哈希表和有序表

### 1.链表

​	· 单向链表节点结构：

​		自己的值+指向下一个节点的指针

​	· 双向链表节点结构：

​		自己的值+指向下一个节点的指针+指向上一个节点的指针

​	· 单向链表和双向链表如何反转？

​	

```java
public class ReverseLinkedList {

    public static class Node{
        public int value;
        public Node next;

        public Node(int data){
            value = data;
        }
    }
    public static class DoubleNode{
        public int value;
        public DoubleNode last;
        public DoubleNode next;

        public DoubleNode(int data){
            value = data;
        }
    }

    //单向链表反转链表
    public static Node reverseLinkedList(Node head){
        Node pre = null;
        Node next = null;
        while (head != null) {
            next = head.next;
            head.next = pre;
            pre = head;
            head = next;
        }
        return pre;
    }

    //双向链表反转链表
    public static DoubleNode reverseDoubleList(DoubleNode head){
        DoubleNode pre = null;
        DoubleNode next = null;
        while (head != null){
            next = head.next;
            head.next = pre;
            head.last = next;
            pre = head;
            head = next;
        }
        return pre;
    }

}
```

​	· 删除单向链表上指定值的元素

```java
public class RemoveValue {

    public static class Node {
        public int value;
        public Node next;

        public Node(int data) {
            value = data;
        }
    }

    public static Node removeValue(Node head, int num) {
        while (head != null) {
            if (head.value != num) {
                break;
            }
            head = head.next;
        }
        // head来到第一个不需要删除的位置
        Node pre = head;
        Node cur = head;
        while (cur != null) {
            if (cur.value == num) {
                pre.next = cur.next;
            } else {
                pre = cur;
            }
            cur = cur.next;
        }
        return head;
    }
}
```



###  2.栈和队列

![img](https://img2018.cnblogs.com/blog/1534783/201812/1534783-20181212143236150-1594812025.png)

​	· 双向链表实现

```java
public class DoubleEndsQueueToStackAndQueue {

    public static class Node<T> {
        public T value;
        public Node<T> last;
        public Node<T> next;

        public Node(T data) {
            value = data;
        }
    }

    public static class DoubleEndsQueue<T> {
        public Node<T> head;//头部元素
        public Node<T> tail;//尾部元素

        //从顶部压入元素
        public void addFromHead(T value) {
            Node<T> cur = new Node<T>(value);
            if (head == null) {
                head = cur;
                tail = cur;
            } else {
                cur.next = head;
                head.last = cur;
                head = cur;
            }
        }

        //从底部压入元素
        public void addFromBottom(T value) {
            Node<T> cur = new Node<T>(value);
            if (tail == null) {
                head = cur;
                tail = cur;
            } else {
                cur.last = tail;
                tail.next = cur;
                tail = cur;
            }
        }

        //从头部取出元素
        public T popFromHead() {
            if (head == null) {
                return null;
            }

            Node<T> cur = head;
            if (head == tail) {
                head = null;
                tail = null;
            } else {
                head = head.next;
                cur.next = null;
                head.last = null;
            }
            return cur.value;
        }

       
        //判断是否为空
        public boolean isEmpty(){
            return head == null;
        }
    }

    //实现栈
    public static class MyStack<T> {
        private DoubleEndsQueue<T> queue;

        public MyStack(){
            queue = new DoubleEndsQueue<T>();
        }

        public void push(T value){
            queue.addFromHead(value);
        }

        public T pop(){
            return queue.popFromHead();
        }

        public boolean isEmpty(){
            return queue.isEmpty();
        }

    }

    //实现队列
    public static class MyQueue<T> {
        private DoubleEndsQueue<T> queue;

        public MyQueue(){
            queue = new DoubleEndsQueue<T>();
        }

        public void push(T value){
            queue.addFromBottom(value);
        }

        public T pop(){
            return queue.popFromHead();
        }

        public boolean isEmpty(){
            return queue.isEmpty();
        }

    }
}
```

​	· 数组实现		

```java
public class RingArray {

    public static class MyQueue {
        private int[] arr;
        private int pushi;//放入新元素的位置
        private int polli;//取出新元素的位置
        private int size;
        private final int limit;

        public MyQueue(int limit) {
            arr = new int[limit];
            pushi = 0;
            polli = 0;
            size = 0;
            this.limit = limit;
        }

        public void push(int value) {
            if (size == limit) {
                throw new RuntimeException("栈满了，不能再加了");
            }
            size++;
            arr[pushi] = value;
            pushi = nextIndex(pushi);
        }

        public int pop() {
            if (size == 0) {
                throw new RuntimeException("栈空了，不能再拿了");
            }
            size--;
            int ans = arr[polli];
            polli = nextIndex(polli);
            return ans;
        }

        public boolean isEmpty() {
            return size == 0;
        }

        //如果现在的下标是i，请返回下一个位置
        public int nextIndex(int i) {
            return i < limit - 1 ? i + 1 : 0;
        }

    }

}
```

### 递归

 	本质上是利用系统的栈将每次递归的状态储存起来，最下层递归操作完成后，依次返回执行。



####  	Master公式：

​	形如T(N) = a*T(N/b) + O(N^d)的递归函数，可直接用Master函数来确定复杂度

​	如果log(b,a) < d,复杂度为O(N^d)

​	如果log(b,a) > d,复杂度为O(N^log(b,a))

​	如果log(b,a) == d,复杂度为O(N^d * log N)

### 哈希表和有序表



# 归并排序和随机排序



### 归并排序

​	将数组分为左右两部分，然后将左右两部分排序，时间复杂度O(N*log N)

​	经常用于计算数组某个数左侧与右侧有多少比它大(小)的问题。

​	

```java
public class MergeSort {

    //递归实现
    public static void mergeSort1(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }

    }

    public static void process(int[] arr, int L, int R) {
        if (L == R) {
            return;
        }
        int mid = L + ((R - L) >> 1);
        process(arr, L, mid);
        process(arr, mid + 1, R);
        merge(arr, L, mid, R);
    }

    public static void merge(int[] arr, int L, int M, int R) {
        int[] help = new int[R - L + 1];
        int i = 0;
        int p1 = L;
        int p2 = M + 1;
        while (p1 <= M && p2 <= R) {
            help[i++] = arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++];
        }
        //要么p1越界，要么p2越界，下方两个while只会发生一个
        while (p1 <= M) {
            help[i++] = arr[p1++];
        }
        while (p2 <= R) {
            help[i++] = arr[p2++];
        }
        for (i = 0; i < help.length; i++) {
            arr[L + i] = help[i];
        }
    }


    //非递归实现
    public static void mergeSort2(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        int N = arr.length;
        int mergeSize = 1;//当前有序的，左组长度
        while (mergeSize < N) {
            int L = 0;
            while (L < N) {
                //L..M左组
                int M = L + mergeSize - 1;
                if (M >= N) {
                    break;
                }
                //L..M左组  M+1..R右组
                int R = Math.min(M + mergeSize, N - 1);
                merge(arr, L, M, R);
                L = R + 1;
            }
            //防止数组长度很大时，mergeSize越过int最大界限
            if (mergeSize > N / 2) {
                break;
            }
            mergeSize <<= 1;
        }
    }
}
```



### 快速排序

​	partition过程

​	   

# 比较器与堆排序

### 堆排序

​	1.先让整个数组都变成大根堆的结构，建立堆的过程：

​		1.1从上至下的方式：时间复杂度O(N*log N)

​		1.2从下至上的方式：时间复杂度O(N)

​	2.把堆的最大值和堆末尾的值交换，然后减小堆的大小之后再去调整堆,一直周而复始，时间复杂度为O(N*log N)

​	3.堆的大小为0之后，排序完成

### 比较器

​	1.比较器的实质是重载比较运算符

​	2.比较器可以很好的应用在特殊标准的排序上

​	3.比较器可以很好的应用于根据特殊标准排序的结构上

​	4.写代码会变得异常容易，还适用于泛型编程



# 前缀树、桶排序和排序的稳定性

### 前缀树

​	1.单个字符串中，字符从前往后的加到一棵多叉树上

​	2.字符放在路上，节点上有专属的数据项（常见的是pass和end值）

​	3.所有样本都这样添加，如果没有路就新建，如果有路就复用

​	4.沿途节点的pass值增加1，每个字符串结束时来到的节点的end值增加1

### 桶排序思想的排序：基数排序&计数排序

​	1.桶排序思想下的排序都是不基于比较的排序

​	2.时间复杂度O(N),额外空间负载度O(M)

​	3.应用范围有限，需要样本的数据状况满足桶的划分

### 排序的稳定性

​	1.排序完成时相等的元素能不能保持原先的次序

​	2.排序的稳定性取决于处理相等元素时的做法

![排序算法的稳定性](https://pica.zhimg.com/v2-0872ff222124611b3403a888be76c2b9_1440w.jpg?source=172ae18b)

### 排序算法总结

​	1.不基于比较的排序，对样本数据有严格要求，不易改写

​	2.基于比较的排序，只要规定好两个样本怎么比较大小就可以直接复用

​	3.基于比较的排序，时间复杂度的极限是O(N*log N)

​	4.时间复杂度O(N*log N)、额外空间复杂度低于O(N)、且稳定的排序不存在

​	5.为了绝对的速度选择快排、为了省空间选择堆排、为了稳定性选择归并

### 常见的坑

​	1.归并排序的额外空间复杂度可以变成O(1),"归并排序内部缓存法"，但是将变得不稳定

​	2."原地归并排序"会让时间复杂度变成O(N^2)

​	3.快速排序稳定性改进，"01 stable sort",但是对样本数据提出了要求

# 链表

### 快慢指针

​	1.输入链表头节点，奇数长度返回中点，偶数长度返回上中点

​	2.输入链表头节点，奇数长度返回中点，偶数长度返回下中点

​	3.输入链表头节点，奇数长度返回中点的前一个，偶数长度返回上中点的前一个

​	4.输入链表头节点，奇数长度返回中点的前一个，偶数长度返回下中点的前一个

### 拓展

​	判断一个链表是不是回文结构

